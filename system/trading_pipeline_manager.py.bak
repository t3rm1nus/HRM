# system/trading_pipeline_manager.py
"""
Trading Pipeline Manager - Orquesta el flujo completo de trading.
Paper-safe, sin llamadas a APIs inexistentes.
"""

import time
import pandas as pd
from typing import Dict, List, Optional, Any
from core.logging import logger
from system.models import TradingCycleResult


class TradingPipelineManager:

    def __init__(
        self,
        portfolio_manager,
        order_manager,
        l2_processor,
        position_rotator,
        auto_rebalancer,
        signal_verifier,
        state_coordinator,
        mode: str = "simulated"
    ):
        self.portfolio_manager = portfolio_manager
        self.order_manager = order_manager
        self.l2_processor = l2_processor
        self.position_rotator = position_rotator
        self.auto_rebalancer = auto_rebalancer
        self.signal_verifier = signal_verifier
        self.state_coordinator = state_coordinator
        self.mode = mode
        
        # Auto-learning bridge (injected from main.py)
        self.auto_learning_bridge = None

    # ==================================================================
    # MAIN PIPELINE
    # ==================================================================

    async def process_trading_cycle(
        self,
        state: Dict,
        market_data: Dict[str, pd.DataFrame],
        cycle_id: int = 0
    ) -> TradingCycleResult:
        """Ejecuta un ciclo completo de trading."""
        start_time = pd.Timestamp.utcnow()

        if not state:
            raise ValueError("System state not injected")
        
        # Add version to state if it doesn't exist
        if "version" not in state:
            state["version"] = "1.0"

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SNAPSHOT INICIAL DEL CICLO - UN SOLO PUNTO DE VERDAD
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Todos los balances se obtienen UNA SOLA VEZ al inicio del ciclo
        # Esto garantiza consistencia y evita mÃºltiples llamadas al exchange
        
        # 1. Obtener snapshot de balances (Ãºnica llamada al ciclo)
        balances_snapshot = await self.portfolio_manager.get_balances_async()
        
        # 2. Extraer precios del market_data
        prices_snapshot = {}
        for symbol, df in market_data.items():
            if df is not None and not df.empty:
                prices_snapshot[symbol] = float(df.iloc[-1]['close'])
        
        # 3. Crear cycle_context - fuente Ãºnica de verdad para todo el ciclo
        cycle_context = {
            "cycle_id": cycle_id,
            "balances": balances_snapshot,
            "prices": prices_snapshot,
            "timestamp": pd.Timestamp.utcnow().isoformat()
        }
        
        # 4. Guardar para referencia
        self.cycle_balances = balances_snapshot
        self.cycle_context = cycle_context
        
        logger.info(f"ğŸ“¸ CYCLE SNAPSHOT | Cycle {cycle_id} | Balances: {balances_snapshot} | Prices: {prices_snapshot}")

        result = TradingCycleResult(
            signals_generated=0,
            orders_executed=0,
            orders_rejected=0,
            cooldown_blocked=0,
            l3_regime="unknown",
            portfolio_value=0.0,
            execution_time=0.0
        )

        try:
            # TEST MODE: Forzar entrada inicial pequeÃ±a si el portfolio tiene poco crypto
            # CRITICAL FIX: Usar cycle_context en lugar de llamar a get_balances_async()
            if cycle_id == 10:
                # Calcular valores desde el snapshot del ciclo
                balances = cycle_context.get("balances", {})
                prices = cycle_context.get("prices", {})
                
                usdt_balance = balances.get("USDT", 0.0)
                btc_balance = balances.get("BTC", 0.0)
                eth_balance = balances.get("ETH", 0.0)
                btc_price = prices.get("BTCUSDT", 0.0)
                eth_price = prices.get("ETHUSDT", 0.0)
                
                portfolio_value = usdt_balance + (btc_balance * btc_price) + (eth_balance * eth_price)
                crypto_value = (btc_balance * btc_price) + (eth_balance * eth_price)
                
                if crypto_value < 50:  # Menos del 10% si portfolio total es ~$500
                    logger.warning("TEST MODE: Forzando BUY inicial pequeÃ±o para romper cash")
                    
                    if btc_price > 0:
                        buy_amount_usdt = usdt_balance * 0.20  # 20% de USDT disponible
                        btc_quantity = buy_amount_usdt / btc_price
                        
                        # Crear orden de compra fake
                        fake_order = {
                            'symbol': 'BTCUSDT',
                            'action': 'buy',
                            'quantity': btc_quantity,
                            'price': btc_price,
                            'status': 'pending',
                            'timestamp': pd.Timestamp.utcnow().isoformat(),
                            'source': 'test_mode'
                        }
                        
                        # Ejecutar la orden
                        executed_order = await self.order_manager.execute_orders([fake_order])
                        filled = [o for o in executed_order if o.get("status") == "filled"]
                        if filled:
                            logger.info(f"âœ… TEST MODE: Orden de compra ejecutada - BTC {btc_quantity:.6f} @ ${btc_price:.2f}")
                            result.orders_executed += len(filled)
                            # Actualizar portfolio
                            await self._update_portfolio_from_orders(filled, market_data)

            # PASO 1 â€“ L3
            l3_output = await self._update_l3_decision(state, market_data)
            result.l3_regime = l3_output.get("regime", "unknown")

            # PASO 2 â€“ L2
            l2_signals = await self._generate_l2_signals(state, market_data, l3_output)
            result.signals_generated = len(l2_signals)

            # PASO 3 â€“ VerificaciÃ³n
            valid_signals = await self._validate_signals(l2_signals, market_data)
            
            # Calcular seÃ±ales rechazadas por cooldown para mÃ©tricas de oportunidad perdida
            signals_rejected_due_to_cooldown = len(l2_signals) - len(valid_signals)
            if signals_rejected_due_to_cooldown > 0:
                # Estimaciones para cÃ¡lculo de oportunidad perdida
                avg_trade_value = 50  # Valor promedio por trade (USDT)
                win_rate = 0.6  # Tasa de victorias (60%)
                
                opportunity_cost = signals_rejected_due_to_cooldown * avg_trade_value * win_rate
                logger.warning(f"âš ï¸ Oportunidad perdida por cooldown: ${opportunity_cost:.2f}")
                
            # Si no hay seÃ±ales vÃ¡lidas, saltar ejecuciÃ³n pero mantener el flujo
            if not valid_signals:
                logger.debug("No hay seÃ±ales vÃ¡lidas en este ciclo")

            # PASO 4 â€“ Generar Ã³rdenes
            # Pass L3 regime to order generation for adaptive cooldown
            l3_regime = l3_output.get("regime", "unknown")
            orders = await self.order_manager.generate_orders(state, valid_signals, l3_regime) if valid_signals else []

            # PASO 5 â€“ Validar Ã³rdenes
            validated_orders = await self._validate_orders(orders, state) if orders else []

            # PASO 6 â€“ Ejecutar Ã³rdenes
            executed = await self.order_manager.execute_orders(validated_orders) if validated_orders else []

            # Clasificar Ã³rdenes ejecutadas
            filled = [o for o in executed if o.get("status") == "filled"]
            rejected = [o for o in executed if o.get("status") == "rejected"]

            result.orders_executed = len(filled)
            result.orders_rejected = len(rejected)

            # PASO 6B â€“ REGISTRAR TRADES PARA AUTO-LEARNING
            if filled and self.auto_learning_bridge:
                logger.info(f"ğŸ¤– AUTO-LEARNING: Registrando {len(filled)} trades ejecutados...")
                for order in filled:
                    try:
                        # Usar market_data actualizado para obtener precios consistentes
                        symbol = order.get('symbol')
                        if symbol in market_data:
                            # Usar Ãºltimo precio disponible para contexto
                            current_price = market_data[symbol].iloc[-1]['close']
                            order['context_price'] = current_price
                            
                        await self.auto_learning_bridge.record_order_execution(
                            order=order,
                            l3_context=l3_output,
                            market_data=market_data
                        )
                        logger.info(f"ğŸ¤– AUTO-LEARNING: Trade registrado - {order.get('symbol')} {order.get('action')}")
                    except Exception as al_error:
                        logger.error(f"âŒ AUTO-LEARNING: Error registrando trade: {al_error}")
            elif filled and not self.auto_learning_bridge:
                logger.warning(f"âš ï¸ AUTO-LEARNING: Hay {len(filled)} trades ejecutados pero el bridge no estÃ¡ conectado")
            
            # PASO 6C â€“ REGISTRAR TRADES EN PAPER TRADE LOGGER (EXPLÃCITO)
            if filled:
                logger.info(f"ğŸ“ PAPER TRADE LOGGER: Registrando {len(filled)} trades ejecutados...")
                try:
                    from storage.paper_trade_logger import log_paper_trade, get_paper_logger
                    
                    # Verificar que el logger estÃ© disponible
                    logger_instance = get_paper_logger()
                    logger.info(f"âœ… PaperTradeLogger disponible - {len(logger_instance.trades)} trades existentes")
                    
                    # Loggear cada trade
                    for order in filled:
                        log_paper_trade(order, market_data=market_data, cycle_id=cycle_id, strategy=l3_output.get('strategy_type', 'paper'))
                    
                    # Forzar guardado explÃ­cito
                    logger_instance._save_json()
                    logger_instance._append_to_csv(order)  # Guardar Ãºltimo trade
                    logger.info(f"âœ… PaperTradeLogger: {len(filled)} trades registrados correctamente")
                    
                    # Verificar trades en base de datos
                    if len(logger_instance.trades) > 0:
                        logger.info(f"ğŸ“Š PaperTradeLogger: Total trades en sesiÃ³n: {len(logger_instance.trades)}")
                        recent_trades = logger_instance.get_recent_trades(5)
                        for trade in recent_trades:
                            logger.debug(f"   - {trade['timestamp']}: {trade['symbol']} {trade['side']} {trade['quantity']:.6f} @ {trade['price']:.2f}")
                    else:
                        logger.warning("âš ï¸ PaperTradeLogger: No hay trades registrados en la sesiÃ³n")
                        
                except Exception as ptl_error:
                    logger.error(f"âŒ PaperTradeLogger: Error al registrar trades: {ptl_error}")

            # PASO 7 â€“ ACTUALIZAR PORTFOLIO (CRÃTICO)
            if filled:
                # CRITICAL FIX: Asegurar precios consistentes antes de actualizar portfolio
                await self._update_portfolio_with_consistent_prices(filled, market_data)
                await self._update_portfolio_from_orders(filled, market_data)

            # PASO 7B â€“ SINCRONIZAR PRECIOS ENTRE COMPONENTES (CRÃTICO)
            # Asegurar que todos los componentes usen los mismos precios para cÃ¡lculos consistentes
            synced_portfolio_value = await self._sync_prices_with_market_data(market_data, result.portfolio_value)
            if synced_portfolio_value > 0:
                result.portfolio_value = synced_portfolio_value
                logger.info(f"ğŸ’° Portfolio value actualizado tras sincronizaciÃ³n de precios: ${synced_portfolio_value:.2f}")

            # PASO 8 â€“ Sincronizar portfolio con cliente (single source of truth)
            await self._sync_portfolio_with_client()

            # PASO 9 â€“ Refrescar STATE desde portfolio real (ASYNC FIX)
            await self._sync_state_from_portfolio_async(state, market_data)

            # PASO 10 â€“ Actualizar estado global en StateCoordinator
            # Usar precios ya sincronizados para actualizar el estado
            coordinator_value = await self._update_state_coordinator(state, market_data, l3_output)
            # Priorizar el valor sincronizado si es vÃ¡lido
            if coordinator_value > 0 and result.portfolio_value <= 0:
                result.portfolio_value = coordinator_value

            # PASO 11 â€“ RotaciÃ³n (opcional)
            rotation_result = await self._process_position_rotation(state, market_data, result)
            if rotation_result:
                result.orders_executed += rotation_result

            # PASO 12 â€“ Rebalance (opcional)
            rebalance_result = await self._process_rebalancing(state, market_data, l3_output, valid_signals, result)
            if rebalance_result:
                result.orders_executed += rebalance_result

        except Exception as e:
            logger.error(f"âŒ Error en ciclo de trading: {e}", exc_info=True)
            # No re-lanzar la excepciÃ³n para mantener el pipeline funcionando

        finally:
            result.execution_time = (pd.Timestamp.utcnow() - start_time).total_seconds()
            logger.info(
                f"â±ï¸ Ciclo completado en {result.execution_time:.2f}s | "
                f"SeÃ±ales: {result.signals_generated} | "
                f"Ã“rdenes: {result.orders_executed} ejecutadas, {result.orders_rejected} rechazadas"
            )

        return result

    # ==================================================================
    # CORE PIPELINE METHODS
    # ==================================================================

    async def _record_trades_for_auto_learning(
        self, 
        filled_orders: List[Dict], 
        l3_output: Dict, 
        market_data: Dict
    ) -> None:
        """Registra trades ejecutados para auto-learning."""
        if not filled_orders or not self.auto_learning_bridge:
            if filled_orders and not self.auto_learning_bridge:
                logger.warning(
                    f"âš ï¸ AUTO-LEARNING: Hay {len(filled_orders)} trades ejecutados pero el bridge no estÃ¡ conectado"
                )
            return

        logger.info(f"ğŸ¤– AUTO-LEARNING: Registrando {len(filled_orders)} trades ejecutados...")
        for order in filled_orders:
            try:
                # Usar market_data actualizado para obtener precios consistentes
                symbol = order.get('symbol')
                if symbol in market_data:
                    # Usar Ãºltimo precio disponible para contexto
                    current_price = market_data[symbol].iloc[-1]['close']
                    order['context_price'] = current_price

                await self.auto_learning_bridge.record_order_execution(
                    order=order,
                    l3_context=l3_output,
                    market_data=market_data
                )
                logger.info(
                    f"ğŸ¤– AUTO-LEARNING: Trade registrado - {order.get('symbol')} "
                    f"{order.get('action')} @ {order.get('price', 'N/A')}"
                )
            except Exception as al_error:
                logger.error(f"âŒ AUTO-LEARNING: Error registrando trade: {al_error}")

    # CRITICAL FIX: Asegurar que PortfolioManager use precios consistentes
    async def _update_portfolio_with_consistent_prices(self, filled_orders: List[Dict], market_data: Dict) -> None:
        """Actualiza portfolio con precios consistentes del market_data"""
        for order in filled_orders:
            symbol = order.get('symbol')
            if symbol in market_data and market_data[symbol] is not None:
                # Usar el precio de cierre mÃ¡s reciente
                current_price = float(market_data[symbol].iloc[-1]['close'])
                logger.info(f"ğŸ’° Usando precio consistente para {symbol}: ${current_price}")
                # Actualizar el precio en el order para cÃ¡lculos consistentes
                order['consistent_price'] = current_price

    async def _update_portfolio_from_orders(
        self, 
        filled_orders: List[Dict], 
        market_data: Dict
    ) -> None:
        """Actualiza el portfolio con Ã³rdenes ejecutadas."""
        try:
            await self.portfolio_manager.update_from_orders_async(filled_orders, market_data)
            
            # âœ… Log NAV despuÃ©s de cada trade ejecutado
            await self._log_nav_with_client(market_data)
            
        except Exception as e:
            logger.error(f"âŒ Error actualizando portfolio desde Ã³rdenes: {e}")

    async def _sync_portfolio_with_client(self) -> None:
        """Sincroniza portfolio con cliente (single source of truth)."""
        try:
            if hasattr(self.portfolio_manager, '_sync_from_client_async'):
                await self.portfolio_manager._sync_from_client_async()
            elif hasattr(self.portfolio_manager, '_sync_from_client'):
                self.portfolio_manager._sync_from_client()
        except Exception as e:
            logger.error(f"âŒ Error sincronizando portfolio con cliente: {e}")

    async def _update_state_coordinator(
        self, 
        state: Dict, 
        market_data: Dict, 
        l3_output: Dict
    ) -> float:
        """Actualiza el StateCoordinator y devuelve el valor total del portfolio.
        CRITICAL FIX: Uses cycle_context snapshot instead of calling get_total_value_async().
        """
        try:
            # Usar cycle_context si estÃ¡ disponible
            if hasattr(self, 'cycle_context') and self.cycle_context:
                balances = self.cycle_context.get("balances", {})
                prices = self.cycle_context.get("prices", {})
                
                # Calcular portfolio_value usando snapshot
                portfolio_value = balances.get("USDT", 0.0)
                for symbol in ["BTCUSDT", "ETHUSDT"]:
                    asset = symbol.replace("USDT", "")
                    bal = balances.get(asset, 0.0)
                    price = prices.get(symbol, 0.0)
                    portfolio_value += bal * price
                
                logger.debug(f"ğŸ“Š StateCoordinator using cycle_context: value=${portfolio_value:.2f}")
            else:
                # Fallback solo si no hay cycle_context
                logger.warning("âš ï¸ No cycle_context in _update_state_coordinator, using fresh balances")
                portfolio_value = await self.portfolio_manager.get_total_value_async()
            
            # Actualizar StateCoordinator
            self.state_coordinator.update_total_value(portfolio_value)
            self.state_coordinator.update_market_data(market_data)
            self.state_coordinator.update_l3_output(l3_output)
            
            # Obtener y actualizar estado del portfolio (desde cycle_context)
            portfolio_state = await self._get_portfolio_state_async()
            self.state_coordinator.update_portfolio_state({
                "btc_balance": portfolio_state.get("BTCUSDT", {}).get("position", 0.0),
                "eth_balance": portfolio_state.get("ETHUSDT", {}).get("position", 0.0),
                "usdt_balance": portfolio_state.get("USDT", {}).get("free", 0.0),
                "total_value": portfolio_value
            })
            
            return portfolio_value
            
        except Exception as e:
            logger.error(f"âŒ Error actualizando StateCoordinator: {e}")
            return 0.0

    async def _process_position_rotation(
        self, 
        state: Dict, 
        market_data: Dict, 
        result: TradingCycleResult
    ) -> int:
        """Procesa rotaciÃ³n de posiciones si estÃ¡ habilitada."""
        if not self.position_rotator:
            return 0
            
        try:
            rotation = await self.position_rotator.check_and_rotate_positions(state, market_data)
            if not rotation:
                return 0
                
            executed_rot = await self.order_manager.execute_orders(rotation)
            await self.portfolio_manager.update_from_orders_async(executed_rot, market_data)
            
            filled_rot = len([o for o in executed_rot if o.get("status") == "filled"])
            
            if filled_rot > 0:
                logger.info(f"ğŸ”„ RotaciÃ³n ejecutada: {filled_rot} Ã³rdenes")
                
            return filled_rot
            
        except Exception as e:
            logger.error(f"âŒ Error en rotaciÃ³n de posiciones: {e}")
            return 0

    async def _process_rebalancing(
        self, 
        state: Dict, 
        market_data: Dict, 
        l3_output: Dict,
        valid_signals: List,
        result: TradingCycleResult
    ) -> int:
        """Procesa rebalanceo automÃ¡tico si estÃ¡ habilitado."""
        if not self.auto_rebalancer:
            return 0
            
        try:
            from core.config import TEMPORARY_AGGRESSIVE_MODE, check_temporary_aggressive_mode
            
            # Check if temporary aggressive mode should be disabled
            check_temporary_aggressive_mode()
            
            # CRÃTICO: Verificar si L3 tiene seÃ±al de SELL
            l3_signal = l3_output.get('signal', '').lower()
            l3_regime = l3_output.get('regime', '').lower()
            
            # NO rebalancear si L3 dice SELL!
            if l3_signal == 'sell':
                logger.info(f"â›”ï¸ AutoRebalance BLOCKED - L3 signal is SELL (regime: {l3_regime})")
                return 0
            
            # Bloques de rÃ©gimen que NO deben rebalancear
            no_rebalance_regimes = ['crash', 'panic_sell', 'extreme_fear', 'bear']
            if l3_regime in no_rebalance_regimes:
                logger.info(f"â›”ï¸ AutoRebalance BLOCKED - L3 regime {l3_regime} is dangerous")
                return 0
            
            # Priorizar seÃ±ales L2 sobre rebalance en modo agresivo
            if TEMPORARY_AGGRESSIVE_MODE and len(valid_signals) > 0:
                logger.debug("ğŸ§¯ AutoRebalance skipped in aggressive mode - L2 signals present")
                return 0
            
            # Solo proceder si L3 especÃ­ficamente lo permite
            if l3_output.get('signal') == 'hold' and not l3_output.get('allow_rebalance', False):
                logger.info("â¸ï¸ AutoRebalance skipped - L3 HOLD signal without rebalance permission")
                return 0
            
            rebalance = await self.auto_rebalancer.check_and_execute_rebalance(
                market_data, l3_decision=l3_output
            )
            
            if not rebalance:
                return 0
                
            # Asegurar precios consistentes para el rebalanceo
            for order in rebalance:
                symbol = order.get('symbol')
                if symbol in market_data and not pd.isna(market_data[symbol].iloc[-1]['close']):
                    order['market_price'] = float(market_data[symbol].iloc[-1]['close'])
            
            executed_reb = await self.order_manager.execute_orders(rebalance)
            
            # Actualizar con precios consistentes
            await self.portfolio_manager.update_from_orders_async(executed_reb, market_data)
            
            filled_reb = len([o for o in executed_reb if o.get("status") == "filled"])
            
            if filled_reb > 0:
                logger.info(f"âš–ï¸ Rebalanceo ejecutado: {filled_reb} Ã³rdenes con precios consistentes")
                
            return filled_reb
            
        except Exception as e:
            logger.error(f"âŒ Error en rebalanceo automÃ¡tico: {e}")
            return 0

    # ==================================================================
    # HELPERS
    # ==================================================================

    def _sync_state_from_portfolio(self, state: Dict) -> None:
        """
        Fuente de verdad ÃšNICA: PortfolioManager (SYNC VERSION - deprecated in async contexts)
        """
        portfolio = self.portfolio_manager.get_portfolio_state()

        snapshot = {
            "btc_balance": portfolio.get("BTCUSDT", {}).get("position", 0.0),
            "eth_balance": portfolio.get("ETHUSDT", {}).get("position", 0.0),
            "usdt_balance": portfolio.get("USDT", {}).get("free", 0.0),
            "total_value": portfolio.get("total", 0.0),
        }

        state["portfolio"] = snapshot
        logger.debug(f"âœ… State synced from PortfolioManager: {snapshot}")

    async def _sync_state_from_portfolio_async(self, state: Dict, market_data: Dict) -> None:
        """
        Fuente de verdad ÃšNICA: cycle_context (ASYNC VERSION)
        CRITICAL FIX: Uses cycle_context snapshot instead of calling get_balances_async().
        """
        try:
            # Usar cycle_context si estÃ¡ disponible (SNAPSHOT del ciclo)
            if hasattr(self, 'cycle_context') and self.cycle_context:
                balances = self.cycle_context.get("balances", {})
                prices = self.cycle_context.get("prices", {})
                
                # Calcular total value usando los precios del snapshot
                total_value = balances.get("USDT", 0.0)
                for symbol in ["BTCUSDT", "ETHUSDT"]:
                    asset = symbol.replace("USDT", "")
                    bal = balances.get(asset, 0.0)
                    price = prices.get(symbol, 0.0)
                    total_value += bal * price
            else:
                # Fallback: obtener balances fresh (solo si no hay cycle_context)
                logger.warning("âš ï¸ No cycle_context available, falling back to fresh balances")
                balances = await self.portfolio_manager.get_balances_async()
                total_value = await self.portfolio_manager.get_total_value_async()

            snapshot = {
                "btc_balance": balances.get("BTC", 0.0),
                "eth_balance": balances.get("ETH", 0.0),
                "usdt_balance": balances.get("USDT", 0.0),
                "total_value": total_value,
            }

            state["portfolio"] = snapshot
            logger.debug(f"âœ… State synced from cycle_context (async): {snapshot}")
            
        except Exception as e:
            logger.error(f"âŒ Error sincronizando estado desde portfolio: {e}")
            # Mantener el estado anterior si hay error
            if "portfolio" not in state:
                state["portfolio"] = {}

    async def _get_portfolio_state_async(self) -> Dict:
        """
        Get portfolio state using cycle_context snapshot.
        CRITICAL FIX: Uses cycle_context instead of calling get_balances_async().
        """
        try:
            # Usar cycle_context si estÃ¡ disponible
            if hasattr(self, 'cycle_context') and self.cycle_context:
                balances = self.cycle_context.get("balances", {})
                logger.debug(f"ğŸ“Š Portfolio state from cycle_context: {balances}")
            else:
                # Fallback solo si no hay cycle_context
                logger.warning("âš ï¸ No cycle_context available in _get_portfolio_state_async")
                balances = await self.portfolio_manager.get_balances_async()
            
            return {
                "BTCUSDT": {
                    "position": balances.get("BTC", 0.0), 
                    "free": balances.get("BTC", 0.0)
                },
                "ETHUSDT": {
                    "position": balances.get("ETH", 0.0), 
                    "free": balances.get("ETH", 0.0)
                },
                "USDT": {"free": balances.get("USDT", 0.0)},
            }
        except Exception as e:
            logger.error(f"âŒ Error obteniendo estado del portfolio: {e}")
            return {
                "BTCUSDT": {"position": 0.0, "free": 0.0},
                "ETHUSDT": {"position": 0.0, "free": 0.0},
                "USDT": {"free": 0.0},
            }

    async def _update_l3_decision(self, state: Dict, market_data: Dict) -> Dict:
        """Actualiza la decisiÃ³n L3."""
        from core.l3_processor import get_l3_decision

        try:
            output = get_l3_decision(market_data) or {
                "regime": "neutral",
                "signal": "hold",
                "confidence": 0.5,
                "strategy_type": "fallback",
                "timestamp": pd.Timestamp.utcnow().isoformat(),
            }
        except Exception as e:
            logger.error(f"âŒ Error obteniendo decisiÃ³n L3: {e}")
            output = {
                "regime": "neutral",
                "signal": "hold",
                "confidence": 0.0,
                "strategy_type": "error_fallback",
                "timestamp": pd.Timestamp.utcnow().isoformat(),
            }

        state["l3_output"] = output
        state["l3_last_update"] = time.time()
        return output

    async def _generate_l2_signals(
        self, 
        state: Dict, 
        market_data: Dict, 
        l3_decision: Dict
    ) -> List[Dict]:
        """Genera seÃ±ales L2 basadas en el contexto L3."""
        context = {
            "regime": l3_decision.get("regime"),
            "signal": l3_decision.get("signal"),
            "confidence": l3_decision.get("confidence"),
            "allow_l2": l3_decision.get("allow_l2_signals", True),
            "l3_output": l3_decision,
        }

        try:
            return self.l2_processor.generate_signals_conservative(
                market_data=market_data,
                l3_context=context
            )
        except Exception as e:
            logger.error(f"âŒ Error generando seÃ±ales L2: {e}")
            return []

    async def _validate_signals(self, signals: List[Dict], market_data: Dict) -> List[Dict]:
        """Valida seÃ±ales usando el verificador."""
        valid = []
        for signal in signals:
            try:
                await self.signal_verifier.submit_signal_for_verification(signal, market_data)
                valid.append(signal)
            except Exception as e:
                logger.debug(f"SeÃ±al rechazada: {signal.get('symbol', 'unknown')} - {e}")
                continue
        return valid

    async def _validate_orders(self, orders: List[Dict], state: Dict) -> List[Dict]:
        """Valida Ã³rdenes antes de ejecuciÃ³n."""
        validated = []
        portfolio = state.get("portfolio", {})

        for order in orders:
            if order.get("status") != "pending":
                validated.append(order)
                continue

            try:
                check = self.order_manager.validate_order_size(
                    order.get("symbol"),
                    order.get("quantity"),
                    order.get("price"),
                    portfolio
                )

                if check["valid"]:
                    validated.append(order)
                else:
                    order["status"] = "rejected"
                    order["validation_error"] = check["reason"]
                    validated.append(order)
                    logger.warning(
                        f"Orden rechazada: {order.get('symbol')} - {check['reason']}"
                    )
                    
            except Exception as e:
                logger.error(f"Error validando orden: {e}")
                order["status"] = "rejected"
                order["validation_error"] = f"Validation error: {str(e)}"
                validated.append(order)

        return validated

    def get_cycle_balances(self) -> Dict[str, float]:
        """
        Get the per-cycle balance snapshot.
        
        Returns:
            Dict[str, float]: Balance snapshot for the current cycle
        """
        if hasattr(self, 'cycle_balances'):
            return self.cycle_balances
        return {}

    def get_cycle_context(self) -> Optional[Dict[str, Any]]:
        """
        Get the complete cycle context (balances + prices snapshot).
        
        Returns:
            Dict with cycle_id, balances, prices, and timestamp
            None if no cycle has been processed yet
        """
        if hasattr(self, 'cycle_context') and self.cycle_context:
            return self.cycle_context
        return None

    def _get_simulated_client(self) -> Optional[Any]:
        """Obtiene el cliente simulado del portfolio_manager si estÃ¡ disponible."""
        if hasattr(self.portfolio_manager, 'client'):
            return self.portfolio_manager.client
        return None

    async def _log_nav_with_client(self, market_data: Dict) -> None:
        """Registra NAV usando el cliente simulado para precios precisos."""
        try:
            client = self._get_simulated_client()
            if client is None:
                return
                
            if hasattr(self.portfolio_manager, 'log_nav'):
                self.portfolio_manager.log_nav(market_data, client)
            elif hasattr(self.portfolio_manager, 'log_status'):
                self.portfolio_manager.log_status(market_data, client)
        except Exception as e:
            logger.debug(f"No se pudo registrar NAV: {e}")

    # ==================================================================
    # PRICE SYNCHRONIZATION - CRITICAL FOR CONSISTENCY
    # ==================================================================

    async def _sync_prices_with_market_data(self, market_data: Dict[str, pd.DataFrame], portfolio_value: float = 0.0) -> float:
        """
        Sincroniza precios entre todos los componentes del sistema - VERSIÃ“N SIMPLIFICADA.
        
        Args:
            market_data: Dict con DataFrames de precios por sÃ­mbolo
            portfolio_value: Valor actual del portfolio (para fallback)
            
        Returns:
            float: Valor actualizado del portfolio
        """
        try:
            # Obtener precios actuales del market_data
            current_prices = {}
            for symbol, df in market_data.items():
                if df is not None and not df.empty:
                    current_prices[symbol] = float(df.iloc[-1]['close'])
            
            if not current_prices:
                logger.warning("âš ï¸ No se pudieron extraer precios del market_data")
                return portfolio_value
            
            logger.info(f"ğŸ’° Precios extraÃ­dos: {current_prices}")
            
            # Solo actualizar precios, no calcular NAV aquÃ­
            # El NAV se calcularÃ¡ en otro lugar
            if hasattr(self.portfolio_manager, 'update_current_prices'):
                self.portfolio_manager.update_current_prices(current_prices)
            
            # Devolver el valor existente, no recalcular
            return portfolio_value
            
        except Exception as e:
            logger.error(f"âŒ Error sincronizando precios: {e}")
            return portfolio_value

    def _extract_current_prices(self, market_data: Dict[str, pd.DataFrame]) -> Dict[str, float]:
        """
        Extrae precios actuales del market_data con validaciÃ³n robusta.
        
        Args:
            market_data: Dict con DataFrames de precios por sÃ­mbolo
            
        Returns:
            Dict[str, float]: Diccionario de precios vÃ¡lidos
        """
        current_prices = {}
        
        for symbol, df in market_data.items():
            try:
                # Validar que el DataFrame existe y no estÃ¡ vacÃ­o
                if df is None:
                    logger.debug(f"âš ï¸ {symbol}: DataFrame es None")
                    continue
                    
                if not isinstance(df, pd.DataFrame):
                    logger.warning(f"âš ï¸ {symbol}: No es un DataFrame vÃ¡lido")
                    continue
                    
                if df.empty:
                    logger.debug(f"âš ï¸ {symbol}: DataFrame vacÃ­o")
                    continue

                # Validar que existe la columna 'close'
                if 'close' not in df.columns:
                    logger.warning(f"âš ï¸ {symbol}: No tiene columna 'close'")
                    continue

                # Extraer Ãºltimo precio de cierre
                last_close = df['close'].iloc[-1]
                
                # Validar que el precio es un nÃºmero vÃ¡lido
                if pd.isna(last_close):
                    logger.warning(f"âš ï¸ {symbol}: Precio de cierre es NaN")
                    continue
                    
                price = float(last_close)
                
                if price <= 0:
                    logger.warning(f"âš ï¸ {symbol}: Precio invÃ¡lido (${price})")
                    continue

                # Validar que el precio estÃ¡ dentro de rangos razonables
                if not self._is_price_within_valid_range(symbol, price):
                    logger.warning(f"âš ï¸ {symbol}: Precio fuera de rango vÃ¡lido (${price})")
                    continue

                current_prices[symbol] = price
                logger.debug(f"ğŸ“Š Precio actual {symbol}: ${price:.2f}")
                
            except Exception as e:
                logger.error(f"âŒ Error extrayendo precio para {symbol}: {e}")
                continue
        
        return current_prices

    def _is_price_within_valid_range(self, symbol: str, price: float) -> bool:
        """
        Valida que el precio estÃ© dentro de rangos razonables para el sÃ­mbolo.
        
        Args:
            symbol: SÃ­mbolo del activo
            price: Precio a validar
            
        Returns:
            bool: True si el precio es vÃ¡lido
        """
        # Rangos aproximados para validaciÃ³n (ajustar segÃºn el mercado)
        valid_ranges = {
            'BTCUSDT': (1000.0, 200000.0),
            'ETHUSDT': (100.0, 20000.0),
            'BNBUSDT': (1.0, 2000.0),
            'SOLUSDT': (1.0, 1000.0),
            'ADAUSDT': (0.01, 50.0),
            'DOGEUSDT': (0.001, 10.0),
            'XRPUSDT': (0.01, 50.0),
            'DOTUSDT': (1.0, 500.0),
            'AVAXUSDT': (1.0, 500.0),
            'LINKUSDT': (1.0, 500.0),
            'MATICUSDT': (0.01, 50.0),
            'UNIUSDT': (1.0, 500.0),
            'ATOMUSDT': (1.0, 500.0),
            'LTCUSDT': (1.0, 1000.0),
            'BCHUSDT': (10.0, 5000.0),
            'ALGOUSDT': (0.01, 50.0),
            'VETUSDT': (0.001, 10.0),
            'FILUSDT': (1.0, 500.0),
            'TRXUSDT': (0.001, 10.0),
            'ETCUSDT': (1.0, 500.0),
        }
        
        # Si no hay rango definido, aceptar cualquier precio positivo
        if symbol not in valid_ranges:
            return price > 0
            
        min_price, max_price = valid_ranges[symbol]
        return min_price <= price <= max_price

    async def _sync_prices_with_portfolio_manager(self, current_prices: Dict[str, float]) -> None:
        """
        Sincroniza precios con el PortfolioManager.
        
        Args:
            current_prices: Dict de precios actuales por sÃ­mbolo
        """
        if not current_prices:
            return
            
        try:
            if hasattr(self.portfolio_manager, 'update_current_prices'):
                self.portfolio_manager.update_current_prices(current_prices)
                logger.debug(f"âœ… Precios sincronizados con PortfolioManager: {len(current_prices)} sÃ­mbolos")
            elif hasattr(self.portfolio_manager, 'set_market_prices'):
                self.portfolio_manager.set_market_prices(current_prices)
                logger.debug(f"âœ… Precios sincronizados con PortfolioManager (set_market_prices)")
            else:
                logger.warning("âš ï¸ PortfolioManager no tiene mÃ©todo para actualizar precios")
                
        except Exception as e:
            logger.error(f"âŒ Error sincronizando precios con PortfolioManager: {e}")

    def _sync_prices_with_state_coordinator(self, current_prices: Dict[str, float]) -> None:
        """
        Sincroniza precios con el StateCoordinator.
        
        Args:
            current_prices: Dict de precios actuales por sÃ­mbolo
        """
        if not current_prices:
            return
            
        try:
            if hasattr(self.state_coordinator, 'update_current_prices'):
                self.state_coordinator.update_current_prices(current_prices)
                logger.debug(f"âœ… Precios sincronizados con StateCoordinator: {len(current_prices)} sÃ­mbolos")
            elif hasattr(self.state_coordinator, 'set_current_prices'):
                self.state_coordinator.set_current_prices(current_prices)
                logger.debug(f"âœ… Precios sincronizados con StateCoordinator (set_current_prices)")
            else:
                logger.warning("âš ï¸ StateCoordinator no tiene mÃ©todo para actualizar precios")
                
        except Exception as e:
            logger.error(f"âŒ Error sincronizando precios con StateCoordinator: {e}")

    async def _recalculate_nav_with_prices(self, current_prices: Dict[str, float], fallback_value: float) -> float:
        """
        Recalcula el NAV del portfolio usando precios consistentes.
        
        Args:
            current_prices: Dict de precios actuales por sÃ­mbolo
            fallback_value: Valor a retornar en caso de error
            
        Returns:
            float: Valor actualizado del portfolio
        """
        if not current_prices:
            return fallback_value
            
        try:
            # Intentar usar mÃ©todo especÃ­fico con precios

