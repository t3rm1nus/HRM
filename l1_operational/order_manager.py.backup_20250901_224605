# l1_operational/order_manager.py - CORREGIDO
import logging
import joblib
import pickle
import os
from typing import Dict, Any, Optional
from .config import ConfigObject
from .models import Signal, SignalType, SignalSource, create_signal
import time
logger = logging.getLogger(__name__)

class OrderManager:
    def __init__(self, binance_client=None):
        """
        Inicializa el OrderManager usando la configuraci√≥n de constantes.
        """
        # Usar la configuraci√≥n de constantes directamente
        self.config = ConfigObject  # Tu m√≥dulo config.py
        
        # Cliente Binance
        self.binance_client = binance_client
        
        # Inicializar modelos IA con lazy loading
        self.models = {}
        self._models_loaded = False
        
        # Otras inicializaciones
        self.active_orders = {}
        self.execution_stats = {}
        
        # L√≠mites de riesgo (desde tu config)
        self.risk_limits = ConfigObject.RISK_LIMITS
        self.portfolio_limits = ConfigObject.PORTFOLIO_LIMITS
        self.execution_config = ConfigObject.EXECUTION_CONFIG
        
        # Cargar modelos en background SIN TIMEOUT
        self._load_ai_models_async()
        
        logger.info(f"‚úÖ OrderManager inicializado - Modo: {ConfigObject.OPERATION_MODE}")
        logger.info(f"‚úÖ L√≠mites BTC: {ConfigObject.RISK_LIMITS['MAX_ORDER_SIZE_BTC']}, ETH: {ConfigObject.RISK_LIMITS['MAX_ORDER_SIZE_ETH']}")

    def _load_ai_models_async(self):
        """
        Carga los modelos de forma as√≠ncrona SIN timeout
        """
        import threading
        
        def load_models_thread():
            try:
                self._load_ai_models()
                self._models_loaded = True
                logger.info("‚úÖ Modelos L1 cargados completamente")
            except Exception as e:
                logger.error(f"‚ùå Error cargando modelos L1: {e}")
                # Continuar funcionamiento sin modelos IA
                self._models_loaded = True  # Permitir que el sistema continue
        
        # Iniciar carga en hilo separado
        thread = threading.Thread(target=load_models_thread, daemon=True)
        thread.start()

    def _load_ai_models(self):
        """
        Carga los 3 modelos IA de L1 SIN timeout para modelos pesados
        """
        model_configs = [
            ('logreg', 'models/L1/modelo1_lr.pkl'),
            ('random_forest', 'models/L1/modelo2_rf.pkl'),
            ('lightgbm', 'models/L1/modelo3_lgbm.pkl')
        ]
        
        # Cargar modelos secuencialmente para evitar problemas de memoria
        for model_name, model_path in model_configs:
            try:
                model = self._load_model_safely(model_path, model_name)
                if model:
                    self.models[model_name] = model
                    logger.info(f"‚úÖ Modelo {model_name} cargado desde {model_path}")
                else:
                    logger.error(f"‚ùå Fall√≥ carga de {model_name}")
            except Exception as e:
                logger.error(f"‚ùå Error cr√≠tico cargando {model_name}: {e}")
                # Continuar con otros modelos

    def _load_model_safely(self, path: str, model_name: str):
        """
        Carga con verificaci√≥n previa y sin timeout
        """
        if not os.path.exists(path):
            logger.error(f"‚ùå Archivo de modelo no encontrado: {path}")
            return None
        
        # Verificaci√≥n r√°pida de tama√±o
        file_size = os.path.getsize(path)
        if file_size < 100:
            logger.error(f"‚ùå Archivo demasiado peque√±o: {path} ({file_size} bytes)")
            return None
        
        logger.info(f"üîÑ Cargando {model_name} ({file_size/1024:.1f}KB)...")
        
        # Para modelos grandes, usar m√©todo m√°s eficiente
        if file_size > 1024 * 1024:  # > 1MB
            logger.info(f"üì¶ Modelo grande detectado, usando carga optimizada...")
        
        # M√©todos de carga en orden de eficiencia
        load_methods = [
            ('joblib', lambda: joblib.load(path)),
            ('pickle_rb', lambda: pickle.load(open(path, 'rb'))),
            ('joblib_mmap', lambda: joblib.load(path, mmap_mode='r') if file_size > 10*1024*1024 else None),
        ]
        
        for method_name, load_func in load_methods:
            try:
                model = load_func()
                if model is not None:
                    logger.info(f"‚úÖ {model_name} cargado con {method_name}")
                    return model
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è {method_name} fall√≥ para {model_name}: {str(e)[:100]}")
                continue
        
        logger.error(f"‚ùå Todos los m√©todos fallaron para {model_name}")
        return None

    def get_ai_prediction(self, features: list, symbol: str) -> Dict[str, float]:
        """
        Predicciones con verificaci√≥n de carga y fallback robusto
        """
        if not self._models_loaded:
            logger.debug("[L1] Modelos a√∫n cargando, usando predicci√≥n por defecto")
            return {'ensemble': 0.5}  # Predicci√≥n neutral
        
        if not self.models:
            logger.debug("[L1] No hay modelos cargados, usando predicci√≥n por defecto")
            return {'ensemble': 0.5}
        
        predictions = {}
        
        for model_name, model in self.models.items():
            try:
                if model is None:
                    continue
                
                # Preparar features seg√∫n el modelo
                prediction_value = self._get_model_prediction(model, features)
                predictions[model_name] = float(prediction_value)
                
            except Exception as e:
                logger.error(f"‚ùå Error en predicci√≥n {model_name}: {e}")
                predictions[model_name] = 0.5  # Neutral en caso de error
        
        # Ensemble de los modelos disponibles
        if predictions:
            ensemble_score = sum(predictions.values()) / len(predictions)
            predictions['ensemble'] = ensemble_score
            logger.debug(f"[L1] Ensemble IA para {symbol}: {ensemble_score:.3f} (modelos: {len(predictions)-1})")
        else:
            predictions['ensemble'] = 0.5  # Neutral si no hay predicciones
            logger.warning(f"[L1] Sin modelos disponibles para {symbol}, usando neutral")
        
        return predictions

    def _get_model_prediction(self, model, features: list) -> float:
        """
        Obtiene predicci√≥n optimizada seg√∫n tipo de modelo
        """
        try:
            if hasattr(model, 'predict_proba'):
                # Para LogReg y RandomForest
                pred = model.predict_proba([features])[0]
                return max(pred) if len(pred) > 1 else pred[0]
            elif hasattr(model, 'predict'):
                # Para LightGBM y otros
                return model.predict([features])[0]
            else:
                return 0.5  # Neutral
        except Exception:
            return 0.5  # Fallback neutral

    def process_signals(self, signals: list) -> Dict[str, Any]:
        """
        Procesa se√±ales t√°cticas con modelos IA cuando est√©n disponibles
        """
        processed_orders = []
        
        for signal in signals:
            try:
                # Si hay features disponibles y modelos cargados, usar IA
                if hasattr(signal, 'features') and signal.features and self._models_loaded:
                    # Preparar features para IA
                    feature_vector = self._extract_features_from_signal(signal)
                    if feature_vector:
                        ai_predictions = self.get_ai_prediction(feature_vector, signal.symbol)
                        
                        # Ajustar strength basado en ensemble IA
                        ensemble_score = ai_predictions.get('ensemble', 0.5)
                        original_strength = signal.strength
                        
                        # Modular la se√±al con IA (ensemble > 0.6 = reforzar, < 0.4 = atenuar)
                        if ensemble_score > 0.6:
                            signal.strength *= min(ensemble_score * 1.5, 1.0)
                        elif ensemble_score < 0.4:
                            signal.strength *= max(ensemble_score * 1.5, 0.1)
                        
                        logger.debug(f"[L1] Se√±al {signal.symbol} ajustada por IA: {original_strength:.3f} ‚Üí {signal.strength:.3f}")
                
                # Procesar se√±al (validaci√≥n, ejecuci√≥n, etc.)
                order_result = self._process_single_signal(signal)
                if order_result:
                    processed_orders.append(order_result)
                    
            except Exception as e:
                logger.error(f"‚ùå Error procesando se√±al {signal.symbol}: {e}")
                continue
        
        return {
            'orders_processed': len(processed_orders),
            'orders': processed_orders,
            'models_loaded': self._models_loaded,
            'available_models': list(self.models.keys())
        }
    
    def _extract_features_from_signal(self, signal) -> list:
        """
        Extrae features num√©ricas de una se√±al para los modelos IA
        """
        try:
            features = []
            
            if hasattr(signal, 'features') and isinstance(signal.features, dict):
                # Extraer features OHLCV
                ohlcv = signal.features.get('ohlcv', {})
                features.extend([
                    ohlcv.get('open', 0),
                    ohlcv.get('high', 0),
                    ohlcv.get('low', 0),
                    ohlcv.get('close', 0),
                    ohlcv.get('volume', 0)
                ])
                
                # Extraer indicators
                indicators = signal.features.get('indicators', {})
                features.extend([
                    indicators.get('rsi', 50),
                    indicators.get('macd', 0),
                    indicators.get('macd_signal', 0),
                    signal.strength,
                    signal.confidence
                ])
            
            # Completar hasta 12 features si es necesario
            while len(features) < 12:
                features.append(0.0)
            
            return features[:12]  # Limitar a 12 features
            
        except Exception as e:
            logger.error(f"‚ùå Error extrayendo features: {e}")
            return None
    
    def _process_single_signal(self, signal):
        """
        Procesa una se√±al individual (placeholder)
        """
        # Aqu√≠ ir√≠a la l√≥gica de validaci√≥n y ejecuci√≥n
        return {
            'symbol': signal.symbol,
            'side': signal.side,
            'strength': signal.strength,
            'status': 'processed'
        }

    async def handle_signal(self, signal) -> Dict[str, Any]:
        """
        Maneja una se√±al individual de forma as√≠ncrona.
        Este es el m√©todo que faltaba y que main.py est√° intentando llamar.
        
        Args:
            signal: Se√±al t√°ctica de L2 (TacticalSignal o Signal)
            
        Returns:
            Dict con el resultado del procesamiento de la se√±al
        """
        try:
            # Validar que la se√±al sea v√°lida
            if not hasattr(signal, 'symbol') or not hasattr(signal, 'side'):
                logger.error(f"‚ùå Se√±al inv√°lida: falta symbol o side")
                return {
                    'symbol': 'unknown',
                    'side': 'unknown',
                    'status': 'rejected',
                    'reason': 'invalid_signal_format',
                    'order_id': None
                }
            
            logger.debug(f"üîÑ Procesando se√±al: {signal.symbol} {signal.side}")
            
            # Verificar l√≠mites de riesgo
            if not self._check_risk_limits(signal):
                logger.warning(f"‚ö†Ô∏è Se√±al rechazada por l√≠mites de riesgo: {signal.symbol}")
                return {
                    'symbol': signal.symbol,
                    'side': signal.side,
                    'status': 'rejected',
                    'reason': 'risk_limits_exceeded',
                    'order_id': None
                }
            
            # Si tenemos modelos IA cargados, usar para validaci√≥n adicional
            if self._models_loaded and self.models:
                ai_validation = await self._validate_signal_with_ai(signal)
                if not ai_validation['approved']:
                    logger.info(f"ü§ñ Se√±al rechazada por IA: {signal.symbol} - {ai_validation['reason']}")
                    return {
                        'symbol': signal.symbol,
                        'side': signal.side,
                        'status': 'rejected',
                        'reason': f"ai_validation_{ai_validation['reason']}",
                        'order_id': None,
                        'ai_score': ai_validation.get('score', 0)
                    }
            
            # Calcular cantidad de la orden
            quantity = self._calculate_order_quantity(signal)
            if quantity <= 0:
                logger.warning(f"‚ö†Ô∏è Cantidad calculada inv√°lida para {signal.symbol}: {quantity}")
                return {
                    'symbol': signal.symbol,
                    'side': signal.side,
                    'status': 'rejected',
                    'reason': 'invalid_quantity',
                    'order_id': None
                }
            
            # Ejecutar orden (modo paper/testnet por ahora)
            if self.config.OPERATION_MODE == 'PAPER':
                order_result = self._execute_paper_order(signal, quantity)
            else:
                order_result = await self._execute_real_order(signal, quantity)
            
            # Actualizar estad√≠sticas
            self._update_execution_stats(order_result)
            
            logger.info(f"‚úÖ Se√±al procesada: {signal.symbol} {signal.side} - Status: {order_result['status']}")
            
            return order_result
            
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico procesando se√±al: {e}")
            return {
                'symbol': getattr(signal, 'symbol', 'unknown'),
                'side': getattr(signal, 'side', 'unknown'),
                'status': 'error',
                'reason': f'processing_error: {str(e)[:100]}',
                'order_id': None
            }

    def _check_risk_limits(self, signal) -> bool:
        """
        Verifica los l√≠mites de riesgo para una se√±al.
        """
        try:
            symbol = signal.symbol
            
            # Verificar l√≠mites por s√≠mbolo
            if symbol == 'BTCUSDT':
                max_size = self.risk_limits.get('MAX_ORDER_SIZE_BTC', 0.01)
            elif symbol == 'ETHUSDT':
                max_size = self.risk_limits.get('MAX_ORDER_SIZE_ETH', 0.1)
            else:
                logger.warning(f"‚ö†Ô∏è S√≠mbolo no configurado: {symbol}")
                return False
            
            # Verificar strength m√≠nima
            min_strength = self.risk_limits.get('MIN_SIGNAL_STRENGTH', 0.6)
            if hasattr(signal, 'strength') and signal.strength < min_strength:
                logger.debug(f"Se√±al {symbol} rechazada por strength baja: {signal.strength:.3f} < {min_strength}")
                return False
            
            # Verificar confidence m√≠nima
            min_confidence = self.risk_limits.get('MIN_CONFIDENCE', 0.5)
            if hasattr(signal, 'confidence') and signal.confidence < min_confidence:
                logger.debug(f"Se√±al {symbol} rechazada por confidence baja: {signal.confidence:.3f} < {min_confidence}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error verificando l√≠mites de riesgo: {e}")
            return False

    async def _validate_signal_with_ai(self, signal) -> Dict[str, Any]:
        """
        Valida una se√±al usando los modelos IA cargados.
        """
        try:
            # Extraer features de la se√±al
            features = self._extract_features_from_signal(signal)
            if not features:
                return {'approved': True, 'reason': 'no_features', 'score': 0.5}
            
            # Obtener predicciones IA
            predictions = self.get_ai_prediction(features, signal.symbol)
            ensemble_score = predictions.get('ensemble', 0.5)
            
            # Umbrales de validaci√≥n
            approval_threshold = 0.4  # M√°s permisivo para no bloquear demasiadas se√±ales
            
            if signal.side.lower() == 'buy':
                # Para compras, queremos score alto (>0.4)
                approved = ensemble_score > approval_threshold
                reason = 'low_buy_confidence' if not approved else 'ai_approved'
            elif signal.side.lower() == 'sell':
                # Para ventas, queremos score bajo (<0.6)
                approved = ensemble_score < (1 - approval_threshold)
                reason = 'low_sell_confidence' if not approved else 'ai_approved'
            else:
                approved = True
                reason = 'unknown_side'
            
            return {
                'approved': approved,
                'reason': reason,
                'score': ensemble_score,
                'models_used': len([k for k in predictions.keys() if k != 'ensemble'])
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error en validaci√≥n IA: {e}")
            return {'approved': True, 'reason': 'validation_error', 'score': 0.5}

    def _calculate_order_quantity(self, signal) -> float:
        """
        Calcula la cantidad de la orden basada en la se√±al y l√≠mites de riesgo.
        """
        try:
            symbol = signal.symbol
            base_qty = 0.01  # Cantidad base por defecto
            
            # Obtener l√≠mites del s√≠mbolo
            if symbol == 'BTCUSDT':
                max_qty = self.risk_limits.get('MAX_ORDER_SIZE_BTC', 0.01)
            elif symbol == 'ETHUSDT':
                max_qty = self.risk_limits.get('MAX_ORDER_SIZE_ETH', 0.1)
            else:
                max_qty = base_qty
            
            # Ajustar cantidad basada en strength y confidence
            strength_multiplier = getattr(signal, 'strength', 1.0)
            confidence_multiplier = getattr(signal, 'confidence', 1.0)
            
            # Calcular cantidad final
            calculated_qty = base_qty * strength_multiplier * confidence_multiplier
            final_qty = min(calculated_qty, max_qty)
            
            # Redondear apropiadamente seg√∫n el s√≠mbolo
            if symbol == 'BTCUSDT':
                final_qty = round(final_qty, 5)  # BTC hasta 5 decimales
            elif symbol == 'ETHUSDT':
                final_qty = round(final_qty, 3)  # ETH hasta 3 decimales
            
            logger.debug(f"üí∞ Cantidad calculada para {symbol}: {final_qty} "
                        f"(base={base_qty}, strength={strength_multiplier:.3f}, "
                        f"confidence={confidence_multiplier:.3f})")
            
            return max(final_qty, 0.001)  # M√≠nimo 0.001
            
        except Exception as e:
            logger.error(f"‚ùå Error calculando cantidad: {e}")
            return 0.01  # Cantidad segura por defecto

    def _execute_paper_order(self, signal, quantity: float) -> Dict[str, Any]:
        """
        Ejecuta una orden en modo paper trading.
        """
        try:
            # Simular orden exitosa
            order_id = f"paper_{signal.symbol}_{int(time.time())}"
            
            result = {
                'symbol': signal.symbol,
                'side': signal.side,
                'quantity': quantity,
                'status': 'filled',
                'order_id': order_id,
                'execution_mode': 'paper',
                'filled_price': 0,  # Se completar√≠a con precio de mercado
                'commission': 0,
                'timestamp': time.time()
            }
            
            logger.info(f"üìÑ Orden PAPER ejecutada: {signal.symbol} {signal.side} {quantity}")
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Error en orden paper: {e}")
            return {
                'symbol': signal.symbol,
                'side': signal.side,
                'status': 'error',
                'reason': str(e),
                'order_id': None
            }

    async def _execute_real_order(self, signal, quantity: float) -> Dict[str, Any]:
        """
        Ejecuta una orden real (cuando est√© implementado).
        """
        # Por ahora, redirigir a paper hasta que implementes √≥rdenes reales
        logger.info(f"üîÑ Orden real solicitada, ejecutando en modo paper por seguridad")
        return self._execute_paper_order(signal, quantity)

    def _update_execution_stats(self, order_result: Dict[str, Any]):
        """
        Actualiza estad√≠sticas de ejecuci√≥n.
        """
        try:
            symbol = order_result.get('symbol', 'unknown')
            status = order_result.get('status', 'unknown')
            
            if symbol not in self.execution_stats:
                self.execution_stats[symbol] = {
                    'total_orders': 0,
                    'filled_orders': 0,
                    'rejected_orders': 0,
                    'error_orders': 0
                }
            
            self.execution_stats[symbol]['total_orders'] += 1
            
            if status == 'filled':
                self.execution_stats[symbol]['filled_orders'] += 1
            elif status == 'rejected':
                self.execution_stats[symbol]['rejected_orders'] += 1
            elif status == 'error':
                self.execution_stats[symbol]['error_orders'] += 1
                
        except Exception as e:
            logger.error(f"‚ùå Error actualizando stats: {e}")

    def get_execution_stats(self) -> Dict[str, Any]:
        """
        Retorna estad√≠sticas de ejecuci√≥n.
        """
        return {
            'models_loaded': self._models_loaded,
            'available_models': list(self.models.keys()),
            'execution_stats': self.execution_stats,
            'active_orders': len(self.active_orders)
        }