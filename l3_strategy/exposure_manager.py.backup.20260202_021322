import logging
import pandas as pd
from core.logging import logger

class ExposureManager:
    """Gesti√≥n de exposici√≥n con sincronizaci√≥n real del portfolio."""

    def __init__(self, market_data_provider=None):
        """
        Initialize ExposureManager.

        Args:
            market_data_provider: Provider for market data access
        """
        self.market_data_provider = market_data_provider

    def calculate_rebalancing(self, portfolio_manager, target_allocations: dict) -> dict:
        """
        Calcular rebalanceo basado en POSICIONES REALES del portfolio.
        Unifica exposici√≥n entre portfolio_state_real y portfolio_state_simulated.

        Args:
            portfolio_manager: Manager con posiciones actuales (FUENTE √öNICA DE VERDAD)
            target_allocations: {'BTCUSDT': 0.2, 'ETHUSDT': 0.15, 'USDT': 0.65}

        Returns:
            Dict con decisiones de rebalanceo
        """
        try:
            # ========================================================================================
            # CR√çTICO: USAR PORTFOLIO_MANAGER COMO FUENTE √öNICA DE VERDAD
            # ========================================================================================
            # ‚úÖ OBTENER POSICIONES REALES DESDE PORTFOLIO_MANAGER
            btc_position = portfolio_manager.get_balance('BTC')
            eth_position = portfolio_manager.get_balance('ETH')
            usdt_balance = portfolio_manager.get_balance('USDT')

            # ‚úÖ OBTENER PRECIOS ACTUALES PARA CALCULAR VALORES
            btc_price = self._get_current_price('BTCUSDT')
            eth_price = self._get_current_price('ETHUSDT')

            # ========================================================================================
            # CR√çTICO: UNIFICAR C√ÅLCULO DE EXPOSICI√ìN - NING√öN "0% ALLOCATION" CUANDO HAY POSICIONES
            # ========================================================================================
            # ‚úÖ CALCULAR VALORES REALES EN USDT
            btc_value = btc_position * btc_price if btc_position > 0 else 0.0
            eth_value = eth_position * eth_price if eth_position > 0 else 0.0
            total_value = btc_value + eth_value + usdt_balance

            # ‚úÖ CALCULAR ALLOCATIONS ACTUALES REALES
            # NUNCA mostrar 0% si hay posiciones reales
            current_btc_pct = (btc_value / total_value * 100) if total_value > 0 and btc_position > 0 else 0.0
            current_eth_pct = (eth_value / total_value * 100) if total_value > 0 and eth_position > 0 else 0.0
            current_usdt_pct = (usdt_balance / total_value * 100) if total_value > 0 else 0.0

            logger.info(f"üìä PORTFOLIO STATE REAL (unificado):")
            logger.info(f"   BTC: {btc_position:.6f} units (${btc_value:.2f}) = {current_btc_pct:.1f}%")
            logger.info(f"   ETH: {eth_position:.6f} units (${eth_value:.2f}) = {current_eth_pct:.1f}%")
            logger.info(f"   USDT: ${usdt_balance:.2f} = {current_usdt_pct:.1f}%")
            logger.info(f"   TOTAL VALUE: ${total_value:.2f}")

            # ‚úÖ CALCULAR TARGETS EN USDT
            target_btc_value = total_value * target_allocations.get('BTCUSDT', 0.2)
            target_eth_value = total_value * target_allocations.get('ETHUSDT', 0.15)
            target_usdt_value = total_value * target_allocations.get('USDT', 0.65)

            logger.info(f"üìä TARGET ALLOCATIONS:")
            logger.info(f"   BTC: {target_allocations.get('BTCUSDT', 0.2)*100:.1f}% (${target_btc_value:.2f})")
            logger.info(f"   ETH: {target_allocations.get('ETHUSDT', 0.15)*100:.1f}% (${target_eth_value:.2f})")
            logger.info(f"   USDT: {target_allocations.get('USDT', 0.65)*100:.1f}% (${target_usdt_value:.2f})")

            # ‚úÖ CALCULAR AJUSTES NECESARIOS
            btc_adjustment_value = target_btc_value - btc_value
            eth_adjustment_value = target_eth_value - eth_value
            usdt_adjustment_value = target_usdt_value - usdt_balance

            # ‚úÖ DETERMINAR ACCIONES
            rebalancing = {
                'BTCUSDT': {
                    'current_position': btc_position,
                    'current_value': btc_value,
                    'target_value': target_btc_value,
                    'adjustment_value': btc_adjustment_value,
                    'adjustment_units': btc_adjustment_value / btc_price if btc_price > 0 else 0,
                    'action': self._determine_action(btc_adjustment_value)
                },
                'ETHUSDT': {
                    'current_position': eth_position,
                    'current_value': eth_value,
                    'target_value': target_eth_value,
                    'adjustment_value': eth_adjustment_value,
                    'adjustment_units': eth_adjustment_value / eth_price if eth_price > 0 else 0,
                    'action': self._determine_action(eth_adjustment_value)
                },
                'USDT': {
                    'current_balance': usdt_balance,
                    'target_balance': target_usdt_value,
                    'adjustment': usdt_adjustment_value,
                    'action': 'rebalance_source' if usdt_adjustment_value > 0 else 'hold'
                }
            }

            # ‚úÖ LOG DETALLADO
            logger.info(f"üìä REBALANCING DECISIONS:")
            logger.info(f"   BTC: {rebalancing['BTCUSDT']['action']} {abs(btc_adjustment_value):.2f} USDT")
            logger.info(f"   ETH: {rebalancing['ETHUSDT']['action']} {abs(eth_adjustment_value):.2f} USDT")
            logger.info(f"   USDT: Need {usdt_adjustment_value:.2f} USDT")

            return rebalancing

        except Exception as e:
            logger.error(f"‚ùå Error calculating rebalancing: {e}", exc_info=True)
            return {}

    def _determine_action(self, adjustment_value: float, threshold: float = 50.0) -> str:
        """
        Determinar acci√≥n basada en ajuste necesario.

        Args:
            adjustment_value: Ajuste en USDT (+ = comprar, - = vender)
            threshold: Threshold m√≠nimo para actuar ($50)

        Returns:
            'buy', 'sell', o 'hold'
        """
        if abs(adjustment_value) < threshold:
            return 'hold'
        elif adjustment_value > 0:
            return 'buy'
        else:
            return 'sell'

    def _get_current_price(self, symbol: str) -> float:
        """Obtener precio actual del s√≠mbolo."""
        try:
            # Obtener desde market_data o exchange
            # Implementaci√≥n espec√≠fica seg√∫n tu setup
            if self.market_data_provider:
                return self.market_data_provider.get_price(symbol)
            else:
                # Fallback a precios hardcodeados
                price_map = {
                    'BTCUSDT': 50000.0,
                    'ETHUSDT': 4327.46
                }
                return price_map.get(symbol, 0.0)
        except Exception as e:
            logger.error(f"‚ùå Error getting price for {symbol}: {e}")
            return 0.0

# Mantener compatibilidad con c√≥digo existente
def gestionar_exposicion(universo, portfolio_state, market_data, regime):
    """
    Legacy function para compatibilidad. Deprecated - usar ExposureManager en su lugar.
    """
    logger.debug("‚ö†Ô∏è gestionar_exposicion est√° deprecated. Usar ExposureManager.calculate_rebalancing en su lugar.")

    # Crear una instancia temporal para compatibilidad
    exposure_manager = ExposureManager()

    # Convertir inputs antiguos al nuevo formato
    class LegacyPortfolioManager:
        def get_balance(self, asset):
            asset_key = f"{asset.lower()}_balance"
            return portfolio_state.get(asset_key, 0.0)

    fake_portfolio_manager = LegacyPortfolioManager()

    # Definir target allocations basado en r√©gimen
    if regime.lower() == "bear":
        target_allocations = {'BTCUSDT': 0.20, 'ETHUSDT': 0.20, 'USDT': 0.60}
    elif regime.lower() == "bull":
        target_allocations = {'BTCUSDT': 0.60, 'ETHUSDT': 0.30, 'USDT': 0.10}
    else:
        target_allocations = {'BTCUSDT': 0.50, 'ETHUSDT': 0.30, 'USDT': 0.20}

    return exposure_manager.calculate_rebalancing(fake_portfolio_manager, target_allocations)
